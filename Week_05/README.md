学习笔记
字典树
主要场景用于通过前序或者说前缀，判断想要查找的目标是否在目标区域内：

Trie 的python实现，每一层都是一个{}
    1、初始化的时候，每一层抽象为一个{}，初始化根节点 self.root = {} ,并且当前node初始化一个结束字符'#'
    2、插入操作：首先获取根节点 node = self.root 注意根节点是一个{}
    遍历需要操作的word，每次获得一个字符'S'，查看当前的'S'是否在当前层的{}中
    如果存在，就把node置为'S',继续往下走
    如果不在的话，把这个'S'加入当前层，并且初始化这个'S'为一个{}
    最后一个字符处理完之后，把结束字符加到最后
    3、search操作
    第一步仍然是获取根节点
    遍历word 每一个's' 查看是否在node中，有就继续往下走，没有就返回False
    最后一个字符处理完后，需要check是否有结束字符，如果有返回true,否则说明这只是一个前缀，返回false
    4、start with操作
    基本和search一致，但是走到最后的时候，没有结束字符


并查集：
1、实现的时候三个步骤，初始化parent，一个list []和要处理的元素相同的长度
2、实现合并集合的函数，union(i ,j) 分别找到i,j 的祖先，然后设置一个祖先为另一个元素祖先的祖先，如果祖先相同就不处理
3、实现查找 find(p ,i) 找到i的祖先，方法是当i的祖先不是自己的时候，不断往上迭代i ：i = p[i] 直到i= p[i]

双向BFS：
基本逻辑和BFS一致，区别在于BFS是针对一个队列list进行取出和插入的操作，而双向bfs是针对两个分别从begin和end 发散出来的list中每次最小的哪一个进行操作，操作最小的有一个好处，就是每一轮的操作都是相对而言最少的。

位运算：
常见的位运算，必须记住！
判断奇偶：
x&1 =1 奇数 =0偶数
x/2  x>>1
x = x&(x-1) 去掉最低位的1
x&(-x) 得到最低位的1
x&-x 得到0
x&(~0<<n )  将x右边的n位清零